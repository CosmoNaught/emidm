{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Introduction to Deep Learning Frameworks with Python and PyTorch\"\n",
        "subtitle: \"DIDE Training Series\"\n",
        "date: \"Thursday, 3 April 2025\"\n",
        "date-format: long\n",
        "format:\n",
        "  revealjs:\n",
        "    incremental: false\n",
        "    theme: [default, custom.scss]\n",
        "    footer: \"Introduction to Deep Learning Frameworks with Python and PyTorch · DIDE Training Series · 03 April 2025\"\n",
        "    logo: images/logos.png\n",
        "---\n",
        "\n",
        "\n",
        "# Introduction {.smaller}\n",
        "\n",
        "- We’ll explore Python basics for R users, a new IDE (Positron), and deep learning concepts.\n",
        "- **Goal:** Show you how to use **PyTorch** for training a surrogate infectious disease model.\n",
        "\n",
        "- Structure:\n",
        "  - 2:00 - 2:30: Introduction Slides (python basics, positron, notebooks, deep learning)\n",
        "  - 2:30 - 3:00: Sharing Surrogate Notebook (making sure everyone can run Colab, everyone is zen 🧘)\n",
        "  - 3:00 - 3:30: Hands-on practice running PyTorch and checking it out\n",
        "  - 3:30 - 4:00: Extension exercises and wrap up\n",
        "\n",
        "# 1. Introduction to Python for R Users {.smaller}\n",
        "\n",
        "## Python vs R: Syntax & Structure Reminders {.smaller}\n",
        "\n",
        "- **Syntax:** Python uses indentation instead of `{}`. No `<-` assignment (use `=`).\n",
        "- **Indexing:** Python indices start at 0 (R starts at 1). Slicing in Python excludes end index.\n",
        "- **Data structures:** Python has lists, dicts, tuples (vs R’s vectors, lists, data frames). Python lists are heterogeneous like R lists.\n",
        "- **Example:** \n",
        "  - In Python, `mylist = [10, 20, 30]; mylist[0] = 10`. \n",
        "  - In R, `myvec <- c(10,20,30); myvec[1] = 10`.\n",
        "\n",
        "## Python vs R: Deeper Overview {.smaller}\n",
        "\n",
        "- **Python Workshop:** [Jesse and Paul python-workshop](https://github.com/plietar/python-workshop/tree/main)\n",
        "\n",
        "Feature               R              Python\n",
        "--------------------- -------------- ---------------\n",
        "whitespace            ignored        meaningful\n",
        "data frames & stats   out-of-box     need package\n",
        "packages              fussy          easy\n",
        "operate on language   yes            no\n",
        "modifying variables   copy-on-modify modify-in-place\n",
        "variable assignment   `<-` (madness) `=` (sane)\n",
        "\n",
        "- **OJ Reflections on Above Table:** 🤔\n",
        "\n",
        "## Python vs R: Deeper Overview {.smaller}\n",
        "\n",
        "- **Python Workshop:** [Jesse and Paul python-workshop](https://github.com/plietar/python-workshop/tree/main)\n",
        "- **OJ Edits on Table:** 🤔\n",
        "\n",
        "Feature               R              Python\n",
        "--------------------- -------------- ---------------\n",
        "plotting              heavenly       hell\n",
        "documentation         `roxygen`❤️     `docstrings`😒\n",
        "dependencies hell 😈  moderate       frequent\n",
        "virtual environments  less often     standard\n",
        "\n",
        "# 2. Positron IDE  {.smaller}\n",
        "\n",
        "## What is Positron? {.smaller}\n",
        "\n",
        "- **Positron** is a next-generation IDE from Posit (RStudio) built on VS Code, tailored for data science. It feels like a blend of RStudio and VSCode in one interface.\n",
        "- **Polyglot support:** Comes configured for both R *and* Python out of the box – you can run R scripts and Jupyter Python notebooks in the same environment.\n",
        "- **Familiar interface:** Shares RStudio’s layout (source, console, plots, environment) with VSCode’s extensibility. This makes the transition easier for R users.\n",
        "- **Why use it?** Simplifies working on projects that use R **and** Python together, without switching IDEs. Familiiar IDE experience for R users learning/transitioning to Python.\n",
        "\n",
        " ([Positron](https://positron.posit.co/)) *Positron IDE combines a Visual Studio Code foundation with an RStudio-like layout, supporting multi-language notebooks and scripts (R and Python) seamlessly.*\n",
        "\n",
        "## Benefits for R Users {.smaller}\n",
        "\n",
        "- **Unified Workflow:** Work with `.R` and `.py` files in one place, share workspace and variables. For example, run an R analysis then a Python machine learning step in one project.\n",
        "- **Jupyter integration:** Built-in support for Jupyter notebooks (no separate JupyterLab needed).\n",
        "- **Extensions:** Leverage VSCode extensions (linting, Git integration, etc.) in Positron. Most VSCode extensions (except a few Microsoft-specific) are available ([Fun with Positron | Andrew Heiss – Andrew Heiss](https://www.andrewheiss.com/blog/2024/07/08/fun-with-positron/#:~:text=Extension%20page%20for%20Stan)).\n",
        "- **Transition ease:** Minimal setup – Positron auto-detects R and Python installations. Familiar shortcuts (e.g. Ctrl+Enter to run code) work for both languages.\n",
        "- **REPL-like development experience:** Positron has a REPL-style development environment, similar to RStudio. You can run code, see results, and modify the environment as you go, putting you closer to understanding the code you write. \n",
        "- **Bottom line: Positron lowers the barrier for R programmers to start incorporating Python into their workflow within a single IDE.**\n",
        "\n",
        "# 3. Deep Learning Basics {.smaller}\n",
        "\n",
        "## What is Deep Learning? {.smaller}\n",
        "\n",
        "- **Definition:** Deep learning is a subset of machine learning that uses multi-layered neural networks to simulate complex decision-making, akin to the human brain ([What Is Deep Learning? | IBM](https://www.ibm.com/think/topics/deep-learning#:~:text=Deep%20learning%20is%20a%20subset,applications%20in%20our%20lives%20today)). \n",
        "- **Key idea:** Instead of manual feature engineering, a deep neural network learns representations through layers of neurons.\n",
        "- **Why it matters:** Achieved breakthroughs in image recognition, natural language processing, etc. – many AI applications today are powered by deep learning ([What Is Deep Learning? | IBM](https://www.ibm.com/think/topics/deep-learning#:~:text=Deep%20learning%20is%20a%20subset,applications%20in%20our%20lives%20today)) ([What Is Deep Learning? | IBM](https://www.ibm.com/think/topics/deep-learning#:~:text=Deep%20learning%20is%20an%20aspect,driving%20cars%20and%20generative%20AI)).\n",
        "- **Examples:** Digital assistants (speech recognition), fraud detection, medical image analysis, and even epidemic forecasting models have benefited from deep learning techniques ([What Is Deep Learning? | IBM](https://www.ibm.com/think/topics/deep-learning#:~:text=Deep%20learning%20is%20an%20aspect,driving%20cars%20and%20generative%20AI)).\n",
        "- **In short:** Deep learning can automatically extract complex patterns from data, making it extremely powerful for modeling nonlinear relationships.\n",
        "\n",
        "## Key Concepts: Neural Networks {.smaller}\n",
        "\n",
        "- **Neurons & Layers:** Basic unit is a *neuron* (takes inputs, applies weights and activation). Neurons are organized into layers (input layer -> hidden layers -> output layer). Multiple hidden layers = a “deep” network.\n",
        "- **Activation Functions:** Non-linear functions applied at neurons (e.g. ReLU, sigmoid). They enable networks to learn complex non-linear mappings.\n",
        "- **Loss Function:** Metric that quantifies error between the network’s prediction and true values (e.g. mean squared error, cross-entropy). The network’s goal is to minimize this during training.\n",
        "- **Forward Propagation:** Data flows through the network layer by layer to produce an output (prediction) ([What Is Deep Learning? | IBM](https://www.ibm.com/think/topics/deep-learning#:~:text=Deep%20neural%20networks%20consist%20of,prediction%20or%20classification%20is%20made)).\n",
        "- **Backpropagation:** The training algorithm – compute the loss, then propagate the error gradients backward adjusting weights (via gradient descent) ([What Is Deep Learning? | IBM](https://www.ibm.com/think/topics/deep-learning#:~:text=Another%20process%20called%20backpropagation%C2%A0uses%20algorithms%2C,backpropagation%20enable%20a%20neural%20network)). This is how the network “learns” from mistakes.\n",
        "- **Optimization:** An optimizer (SGD, Adam, etc.) uses those gradients to update weights iteratively, gradually improving the model’s performance.\n",
        "\n",
        "## Training Process Recap {.smaller}\n",
        "\n",
        "- **Initialize** weights (often random small values).\n",
        "- **Forward pass:** Input data -> compute outputs and loss.\n",
        "- **Backward pass:** Compute gradients of loss w.rt each weight (this is automatic via backpropagation).\n",
        "- **Weight update:** Adjust weights using gradients (optimizer step).\n",
        "- **Iterate:** Repeat for many epochs (passes through data) until loss converges or performance is sufficient.\n",
        "- **Result:** A trained neural network model that hopefully generalizes to new data.\n",
        "- Throughout training, we monitor metrics on a **validation set** to avoid overfitting. If validation performance plateaus or worsens, we consider techniques like early stopping or regularization.\n",
        "\n",
        "# 4. Introduction to PyTorch {.smaller}\n",
        "\n",
        "## What is PyTorch? {.smaller}\n",
        "\n",
        "- **PyTorch** is an open-source deep learning framework based on Python (and Torch library). It’s one of the most popular platforms for deep learning research and deployment ([What is PyTorch?](https://www.techtarget.com/searchenterpriseai/definition/PyTorch#:~:text=PyTorch%20is%20an%20open%20source,between%20research%20prototyping%20and%20deployment)).\n",
        "- Developed by researchers at **Facebook (Meta)** in 2016, it accelerated from prototyping to production with a flexible, pythonic approach ([What is PyTorch?](https://www.techtarget.com/searchenterpriseai/definition/PyTorch#:~:text=PyTorch%20is%20an%20open%20source,between%20research%20prototyping%20and%20deployment)) ([What is PyTorch?](https://www.techtarget.com/searchenterpriseai/definition/PyTorch#:~:text=scripting%20language,between%20research%20prototyping%20and%20deployment)).\n",
        "- **Dynamic computation graph:** PyTorch uses a “define-by-run” approach – the neural network graph is built on the fly as you run code, making it intuitive to debug and modify.\n",
        "- **Why PyTorch?** \n",
        "  - *Easy to learn:* Pythonic API feels natural if you know Python.\n",
        "  - *Flexibility:* Define complex models imperatively (no static graphs).\n",
        "  - *Community & Ecosystem:* Huge community, lots of pre-trained models and tutorials. Backed by Meta and the open-source community (now part of Linux Foundation).\n",
        "- **Usage:** Widely used in academia and industry (Meta uses PyTorch to power all its AI workloads ([What is PyTorch?](https://www.techtarget.com/searchenterpriseai/definition/PyTorch#:~:text=PyTorch%20was%20initially%20an%20internship,for%20driving%20all%20AI%20workloads))). It has become a go-to framework for computer vision, NLP, and many scientific applications.\n",
        "\n",
        "## Core Components of PyTorch {.smaller}\n",
        "\n",
        "- **Tensor:** Fundamental data structure in PyTorch. A tensor is a homogeneous multi-dimensional array (similar to a NumPy array) that can be processed on CPU or GPU ([PyTorch - Wikipedia](https://en.wikipedia.org/wiki/PyTorch#:~:text=match%20at%20L412%20homogeneous%20multidimensional,and%20Apple%27s%20Metal)). \n",
        "  - Example: `torch.tensor([[1,2],[3,4]])` is a 2x2 tensor of integers.\n",
        "- **Autograd:** PyTorch’s automatic differentiation engine. It records operations on tensors so that gradients can be computed via backpropagation. This means if you have a loss computed from tensors, you can call `.backward()` to get gradients of all parameters – no manual calculus needed.\n",
        "- **`nn` Module:** High-level neural network APIs. `torch.nn` provides building blocks like layers (Linear, Conv2d, LSTM, etc.), activation functions, loss functions, etc., to easily build complex networks ([PyTorch - Wikipedia](https://en.wikipedia.org/wiki/PyTorch#:~:text=PyTorch%20defines%20a%20module%20called,Networks%20are%20built%20by%20inheriting)).\n",
        "  - You define a neural network as a class inheriting `nn.Module`, compose layers in the constructor, and define the forward pass. PyTorch takes care of gradient computation for the parameters.\n",
        "- **Optimizers:** `torch.optim` has algorithms like SGD, Adam for updating model parameters based on computed gradients.\n",
        "- **DataLoader:** Utility to load and batch your dataset conveniently, with shuffling and parallel loading.\n",
        "- *In summary:* PyTorch provides the pieces (tensors + autograd + nn modules) to build and train neural networks efficiently, abstracting away much of the math and boilerplate.\n",
        "\n",
        "## PyTorch in Action: Basic Operations {.smaller}\n",
        "\n",
        "Let’s see a simple example creating a tensor, doing a computation, and using autograd to get gradients:\n"
      ],
      "id": "e1db471e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: true\n",
        "import torch\n",
        "\n",
        "# Create a tensor with gradient tracking\n",
        "x = torch.tensor([1.0, 2.0, 3.0], requires_grad=True)\n",
        "# Perform operations on the tensor\n",
        "y = x * 2  # y = [2.0, 4.0, 6.0]\n",
        "y_sum = y.sum()  # y_sum = 12.0 (scalar tensor)\n",
        "# Compute gradients (dy_sum/dx)\n",
        "y_sum.backward()  # backpropagate through the computation\n",
        "print(x.grad)  # Gradient of y_sum w.r.t x\n",
        "# Expected output: tensor([2., 2., 2.])"
      ],
      "id": "59bf38fe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "- In this example, `y = 2*x`, and `y_sum = 2*x1 + 2*x2 + 2*x3`. The gradient ∂(y_sum)/∂x = `[2, 2, 2]`, which PyTorch computes for us.\n",
        "- This illustrates how **autograd** frees us from manual gradient derivation. We can then use these gradients in an optimizer to update `x` (or, typically, model parameters) during training.\n",
        "- PyTorch’s imperative style means we used standard Python control flow to compute `y` and `y_sum`. The framework built the computation graph dynamically and handled differentiation under the hood.\n",
        "\n",
        "# 5. Deep Learning in Infectious Disease Modeling {.smaller}\n",
        "\n",
        "## Why AI in Epidemiology? {.smaller}\n",
        "\n",
        "- **Data-driven insights:** Infectious disease modeling traditionally relies on differential equations and statistical models. Machine learning (ML) offers an alternative approach to identify patterns in epidemiological data (e.g. forecasting outbreaks from trends).\n",
        "- **Deep learning advantages:** Ability to model complex, non-linear relationships. For instance, neural networks can capture patterns in time-series infection data that might be hard to specify in a parametric model.\n",
        "- **Large Development Community:** PyTorch has a large and active community, with many pre-trained models and tutorials. Other popular tools such as Jax/flax underpin the development by large tech companies like Google and Meta, which likely predicates a more robust ecosystem and rapid development and contributions from the community.\n",
        "\n",
        "## Why AI in Epidemiology? {.smaller}\n",
        "\n",
        "- **Enhancing traditional models:** AI can be combined with mechanistic models. For example, researchers have integrated neural networks with compartmental models to help estimate parameters that are hard to infer otherwise ([\n",
        "            Epi-DNNs: Epidemiological priors informed deep neural networks for modeling COVID-19 dynamics - PMC\n",
        "        ](https://pmc.ncbi.nlm.nih.gov/articles/PMC9970927/#:~:text=Differential%20equations,to%20solve%20the%20ordinary%20differential)). This can merge domain knowledge (e.g. SIR model structure) with data-driven flexibility.\n",
        "- **Physics-informed NN:** There is a trend of *physics-informed neural networks* for epidemic forecasting ([Physics-informed deep learning for infectious disease forecasting](https://pubmed.ncbi.nlm.nih.gov/39876937/#:~:text=Physics,area%20of%20scientific%20machine%20learning)) – these models incorporate the known dynamics (e.g. equations of disease spread) into the training of a neural network, ensuring predictions that respect known laws while still learning from data.\n",
        "\n",
        "![](images/pinn.png){style=\"height:300px;\"}\n",
        "\n",
        "\n",
        "## Why AI in Epidemiology? {.smaller}\n",
        "\n",
        "- **Surrogate models:** Using AI to approximate the input-output behavior of complex simulation models. This is particularly useful to speed up scenario analysis in infectious disease simulations that would otherwise be computationally intensive.\n",
        "- **It is likely going to be everywhere:** [Artificial intelligence for modelling infectious disease epidemics](https://www.nature.com/articles/s41586-024-08564-w)\n",
        "\n",
        "![](images/ID_ML.png){style=\"height:400px;\"}\n",
        "\n",
        "## Surrogate Modeling: Bridging Simulation and AI {.smaller}\n",
        "\n",
        "- **What is a surrogate model?** It’s an AI model trained to emulate another process or simulation. For infectious diseases, a surrogate model can learn to reproduce the outcomes of a complex epidemic simulation (e.g. an agent-based model or a stochastic SIR model), given certain inputs, but much faster.\n",
        "- **Why use it?** Simulations (especially stochastic ones) can be slow when exploring many scenarios or doing real-time forecasting. A surrogate (once trained) runs almost instantly, allowing rapid experimentation or even real-time applications (like outbreak forecast updates).\n",
        "- **In epidemiology:** Surrogates can learn the mapping from disease parameters (like transmission rate, recovery rate) to outputs of interest (like peak infected, time series of infections). Then we can query the surrogate for any parameter combination instead of rerunning the simulation.\n",
        "- **Considerations:** Surrogate models need a comprehensive training dataset from the simulation (covering the range of scenarios). They should be validated to ensure they accurately reflect the simulation’s behavior, especially in the regime of interest (e.g. epidemic growth vs decline phases).\n",
        "\n",
        "# 6. Surrogate Modeling for Epidemic Simulations {.smaller}\n",
        "\n",
        "## Case Study: Surrogating a Stochastic SIR Model {.smaller}\n",
        "\n",
        "- We’ll use the classic **SIR model** (Susceptible-Infectious-Recovered) as an example of building a surrogate. In a stochastic SIR simulation, each run with given parameters produces a trajectory of S, I, R over time.\n"
      ],
      "id": "cfd42b44"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | echo: true\n",
        "from emidm.sir import run_sir, run_model_with_replicates, plot_model_outputs\n",
        "plot_model_outputs(run_model_with_replicates(run_sir, reps=10))"
      ],
      "id": "9f9310df",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Building the Surrogate {.smaller}\n",
        "\n",
        "- **1. Generate simulation data:** Sample a range of parameter sets (e.g. transmission rate β, recovery rate γ, possibly initial population sizes). For each set, run the SIR simulation and record the resulting infection curves (S(t), I(t), R(t) over time).\n",
        "- **2. Prepare training dataset:** From these runs, construct input-output pairs for learning. One approach is to provide the parameters (β, γ, time t) as inputs and the corresponding S, I, R at that time as outputs. (Alternatively, train a model that directly outputs the entire time-series given β and γ.)\n",
        "- **3. Train a neural network:** Use PyTorch to define a network (for example, a simple feed-forward network or an RNN) that takes in parameters (and time) and outputs the state. Train it on the simulation data by minimizing the error between the network’s predicted epidemic curve and the simulation’s actual values.\n",
        "- **4. Validate the model:** Test the surrogate on simulation runs it hasn’t seen. Check that it can predict the trajectory for new β, γ with reasonable accuracy (e.g., the peak and timing of infections match the simulation).\n",
        "- **5. Use the surrogate:** Now you have a fast approximation of the SIR model. You can sweep through parameter space quickly, perform uncertainty quantification (by sampling many β, γ from distributions and getting outcomes rapidly), or embed this surrogate inside larger frameworks (e.g., optimization or real-time forecasting systems).\n",
        "\n",
        "## Surrogate Model Visualization (Validation) {.smaller}\n",
        "\n",
        "- Once trained, we can visualize how well the surrogate matches the actual simulation:\n",
        "  - Plot the infection curve from the true simulation and the surrogate’s predicted curve for a few test parameter sets. Ideally, they overlap closely.\n",
        "  - Plot predicted vs actual values (parity plot) for key outcomes (e.g. final epidemic size, peak infection) to quantify accuracy.\n",
        "- If the surrogate is accurate, we can be confident using it for further experiments. For example, we could vary β continuously and see how peak infection changes, using the surrogate outputs instantly rather than running hundreds of simulations.\n",
        "- It’s also insightful to examine the surrogate’s learned parameters. In the SEINN example, the network inferred β and γ. If those learned values align with the true parameters used in simulation, it validates that the network not only predicts well but also captures the underlying epidemic parameters.\n",
        "\n",
        "## Surrogate Notebook {.smaller}\n",
        "\n",
        "[Training Surrogates](https://github.com/OJWatson/emidm/blob/main/examples/surrogate_notebook.ipynb){preview-link=\"false\"}\n",
        "\n",
        "# 7. Alernative Surrogate Approaches\n",
        "\n",
        "## Conditional Variational Autoencoders (cVAEs). What is a cVAE? {.smaller}\n",
        "\n",
        "- A **Conditional Variational Autoencoder (cVAE)** is an extension of the Variational Autoencoder that incorporates additional information (conditions) into the generation process ([Conditional Variational Autoencoders](http://ijdykeman.github.io/ml/2016/12/21/cvae.html#:~:text=however%2C%20produce%20an%20image%20of,the%20encoder%20and%20the%20decoder)).\n",
        "- **Recap VAE:** A VAE consists of an encoder that compresses input data into a latent distribution (usually a Gaussian in a low-dimensional space) and a decoder that reconstructs data from a sample of that latent distribution. It’s trained to reconstruct inputs while keeping latent variables meaningful (via a KL divergence regularization).\n",
        "- **Conditional part:** In a cVAE, we “condition” both encoder and decoder on some extra context. For example, when dealing with images of digits, we can provide the digit label as a condition. The encoder then learns latent variables *given* that label, and the decoder can generate data conditioned on a specific label ([Conditional Variational Autoencoders](http://ijdykeman.github.io/ml/2016/12/21/cvae.html#:~:text=however%2C%20produce%20an%20image%20of,the%20encoder%20and%20the%20decoder)).\n",
        "- **Effect:** This allows directed generation – e.g., “generate samples that look like digit 5” or, in our context, “generate epidemic curves under a certain scenario”. The latent space then captures variations *other than* the condition. \n",
        "  - For digits, the label fixes which digit, and the latent variables can capture style (thickness of writing, slant, etc.) ([Conditional Variational Autoencoders](http://ijdykeman.github.io/ml/2016/12/21/cvae.html#:~:text=To%20generate%20an%20image%20of,which%20the%20number%20is%20written)).\n",
        "  - For epidemics, one could imagine conditioning on, say, the basic reproduction number $R_0$ or other known factors, and the latent variables capture random effects or unknown influences.\n",
        "- **Uncertainty modeling:** cVAEs are useful for representing uncertainty. Instead of a single prediction, a cVAE can generate a *distribution* of possible outcomes for a given condition. For instance, given an initial infection count and $R_0$, a cVAE could generate many possible epidemic trajectories (reflecting stochastic variations).\n",
        "\n",
        "## Potential Application of cVAE in Epidemiology {.smaller}\n",
        "\n",
        "- **Scenario:** We have many observed epidemic curves (from simulations or real data) under various conditions (e.g. different intervention strategies). We want to model the distribution of epidemic outcomes for a new condition.\n",
        "- **Using cVAE:** We could train a cVAE where:\n",
        "  - The input to the encoder is an epidemic trajectory with its condition (e.g. “with lockdown” vs “no lockdown”).\n",
        "  - The condition is also fed into the decoder. \n",
        "  - The cVAE learns a latent space of other factors (like unobserved socio-behavioral factors or stochastic effects).\n",
        "- Once trained, for a given condition (say “lockdown from day 30”), we can sample different latent vectors to generate a variety of plausible epidemic curves that all reflect that condition. This gives a principled way to explore uncertainty and variability in outcomes.\n",
        "- **Why cVAE?** Unlike a standard deterministic model, a cVAE provides a distribution of outcomes, not just one. This is valuable for risk assessment – e.g., what’s the worst-case scenario vs best-case scenario under a specific intervention?\n",
        "- **Note:** This is an advanced technique and an active research area. It combines deep learning’s generative power with the need in epidemiology to quantify uncertainty.\n",
        "\n",
        "# Conclusion and Next Steps {.smaller}\n",
        "\n",
        "- We introduced Python’s basics for R users and a conducive environment (Positron) to start combining R and Python in research.\n",
        "- We covered deep learning fundamentals – from what neural networks are to how we train them – setting the stage for using these techniques in epidemiology.\n",
        "- With **PyTorch**, you have a powerful tool to implement deep learning models. We saw how tensors and autograd work, and ran through a simple example.\n",
        "- Machine learning and deep learning are increasingly important in infectious disease modeling:\n",
        "  - **Surrogate models** can accelerate simulation-based research.\n",
        "  - **Advanced models** like cVAEs can capture uncertainty in a principled way.\n",
        "- **Next steps:** \n",
        "  - Hands-on practice: try running a simple PyTorch model (e.g., fit a curve) in Positron.\n",
        "  - Experiment with the SIR surrogate idea: simulate data in R, train a PyTorch model in Python.\n",
        "  - Explore real datasets: Can you use a neural network to forecast cases? How would you incorporate domain knowledge?\n",
        "- By blending R’s strength in statistical modeling with Python’s prowess in deep learning, infectious disease modelers can build more robust, data-driven models to inform public health decisions. Happy coding and modeling!"
      ],
      "id": "116e81b2"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/oj/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}